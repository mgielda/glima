#!/usr/bin/env ruby

################################################################
# rbenv support:
# If this file is a symlink, and bound to a specific ruby
# version via rbenv (indicated by RBENV_VERSION),
# I want to resolve the symlink and re-exec
# the original executable respecting the .ruby_version
# which should indicate the right version.
#
if File.symlink?(__FILE__) and ENV["RBENV_VERSION"]
  ENV["RBENV_VERSION"] = nil
  shims_path = File.expand_path("shims", ENV["RBENV_ROOT"])
  ENV["PATH"] = shims_path + ":" + ENV["PATH"]
  exec(File.readlink(__FILE__), *ARGV)
end

gemfile = File.expand_path("../../Gemfile", __FILE__)

if File.exists?(gemfile + ".lock")
  ENV["BUNDLE_GEMFILE"] = gemfile
  require "bundler/setup"
end

require "rubygems"
require "glima"
require "cgi"

Encoding.default_external="UTF-8"

class GlimaCLI < Glima::Cli
  package_name 'GLIMA'

  ################################################################
  # register frequently used options

  named_option :format,     :desc => "Set printing format", :enum => %w(short full metadata minimal raw mewl)
  named_option :dry_run,    :desc => "Perform a trial run with no changes made", :type => :boolean
  named_option :query,      :desc => "Filter messages by QUERY"

  ################################################################
  # Command: watch
  ################################################################
  desc "watch", "Watch gmail server and report."


  def watch
    begin
      response = client.get_user_profile('me')
      current_history_id = response.history_id.to_i
      last_history_id ||= current_history_id

      puts "current: #{current_history_id}"

      if current_history_id > last_history_id
        puts "current: #{current_history_id} > last: #{last_history_id}"

        res = client.list_user_histories('me', {start_history_id: last_history_id})
        puts "res.history_id: #{res.history_id}"

        if res.history
          res.history.each do |h|
            history = Glima::Resource::History.new(h)
            puts history.dump
            last_history_id = h.id.to_i
          end
        else
          last_history_id = res.history_id.to_i # update gap
          shell.say("No history, update to #{last_history_id}", :red)
        end
      end

      # sleep if current history Id is up-to-date
      client.wait("[Gmail]/すべてのメール") if current_history_id == last_history_id

    end while true
  end

  ################################################################
  # Command: push
  ################################################################
  desc "push EMAIL_FILE", "Push EMAIL_FILE to INBOX"

  method_option :date,   :desc => "Set date source", :enum => %w(time header)
  method_option :thread, :desc => "Set thread Id"
  method_option :label,  :desc => "List of label names to add separated by comma"

  def push(email_file)
    labels = options[:label]&.split(/ *, */) || []
    label_ids = client.list_user_labels('me').labels.find_all {|lbl| labels.member?(lbl.name)}.map(&:id)
    label_ids += ["INBOX", "UNREAD"]
    thid = options[:thread] || nil
    date = if options[:date] == "header" then "dateHeader" else "receivedTime" end

    File.open(email_file) do |source|
      client.insert_user_message(
        'me',
        Google::Apis::GmailV1::Message.new(label_ids: label_ids, thread_id: thid),
        content_type: "message/rfc822",
        internal_date_source: date,
        upload_source: source) do |msg, err|
        if msg
          puts "pushed to: #{msg.id}"
        else
          STDERR.puts "Error: #{err}"
        end
      end
    end
  end

  ################################################################
  # Command: rezip
  ################################################################
  desc "rezip INPUT_FILE [OUTPUT_FILE]", "Create decrypted and unicode path zip file."

  method_option :password,   :desc => "Password for decryption."
  method_option :attachment, :desc => "Replace attachment of email INPUT_FILE.", :type => :boolean

  def rezip(input_file, output_filename = nil)
    if options[:attachment]
      mail = Glima::Resource::Mail.read(input_file)
      mail.attachments.each do |attachment|
        if attachment.filename =~ /\.zip$/i
          zip = Glima::Zip.new(attachment.body.decoded, options[:password])
          attachment.body = zip.to_decrypted_unicode_zip.to_base64
          attachment.content_transfer_encoding = "base64"
        end
      end
      if output_filename
        File.open(output_filename, "w") do |f|
          f.write(mail.to_s)
        end
      else
        print mail.to_s
      end

    else
      zip = Glima::Zip.read(input_file, options[:password])
      zip.to_decrypted_unicode_zip.write_to_file(output_filename || $stdout)
    end
  end

  ################################################################
  # Command: labels
  ################################################################
  desc "labels", "List labels"

  method_option :verbose, :desc => "Show verbose information for each label.", :type => :boolean

  def labels
    response = client.list_user_labels('me')
    puts 'No labels found' if response.labels.empty?

    all_ids = response.labels.map(&:id)
    total = all_ids.length

    unless options[:verbose]
      response.labels.sort_by(&:name).each do |label|
        # puts "(\"#{label.id}\" . \"#{label.name}\")"
        puts "#{label.name}"
      end
      return 0
    end

    # Gmail API has rate limit at 250 requests/seccond/user (deps on type of method)
    # https://developers.google.com/gmail/api/v1/reference/quota
    # labels.get consumes 1quota unit
    # It is only an experiment, not practical...
    #
    # how to retry batch requests? · Issue #444 · google/google-api-ruby-client
    # https://github.com/google/google-api-ruby-client/issues/444
    # Setting default option should also work, but it has to be done before the service is created.
    #
    # Retries on individual operations within a batch isn't yet
    # supported. It's a bit complicated to do that correctly
    # (e.g. extract the failed requests/responses, build a new batch,
    # retry, repeat... merge all the results...)
    #
    # I'd caution against using retries with batches unless you know
    # the operations are safe to repeat. Since the entire batch is
    # repeated, you may be replaying successful operations as part of
    # it.
    #
    index = 1
    all_ids.each_slice(100) do |ids|
      client.batch do |batch_client|
        ids.each do |id|
          batch_client.get_user_label('me', id) do |label, err|
            if label
              puts "--- #{index}/#{total} -------------------------------------------------"
              # puts Glima::Resource::Label.new(label).dump
              index += 1
            else
              puts "Error: #{err}"
            end
          end
        end # ids
      end # batch
      sleep 1
    end
  end

  ################################################################
  # Command: label
  ################################################################
  desc "label GM_MSGID", "Add/Remove labels to/from GM_MSGID"

  method_option :add, :desc => "List of label names to add separated by comma"
  method_option :remove, :desc => "List of label names to remove separated by comma"

  def label(message_id)
    req = {}

    if add = options[:add]
      req[:add_label_ids] = add.split(/ *, */)
    end

    if remove = options[:remove]
      req[:remove_label_ids] = remove.split(/ *, */)
    end

    if req.empty?
      puts "Do nothing."
      return 0
    end

    req = Google::Apis::GmailV1::ModifyMessageRequest.new(req)

    client.modify_message('me', message_id, req) do |res,err|
      if res
        puts "Update #{message_id} successfully."
      else
        puts "Error: #{err}"
      end
    end
  end

  ################################################################
  # Command: trash
  ################################################################
  desc "trash GM_MSGID ...", "Move messages to trash"

  def trash(*message_ids)
    if message_ids.empty?
      puts "Do nothing."
      return 0
    end

    client.batch do |batch_client|
      message_ids.each do |id|
        batch_client.trash_user_message('me', id) do |res, err|
          if res
            puts "Trash #{id} successfully."
          else
            puts "Error: #{err}"
          end
        end
      end
    end
  end

  ################################################################
  # Command: profile
  ################################################################
  desc "profile", "Show user's profile."

  def profile
    # while true
      response = client.get_user_profile('me')
      puts "emailAddress: #{response.email_address}"
      puts "messagesTotal: #{response.messages_total}"
      puts "threadsTotal: #{response.threads_total}"
      puts "historyId: #{response.history_id}"
    #   STDOUT.flush
    #   _dummy = STDIN.gets
    # end
  end

  ################################################################
  # Command: history
  ################################################################
  desc "history LAST_HISTORY_ID", "List operation history since LAST_HISTORY_ID."

  def history(last_history_id)
    response = nil
    next_page_token = nil

    begin
      opt = {start_history_id: last_history_id}
      opt[:page_token] = next_page_token if next_page_token

      client.list_user_histories('me', opt) do |res, err|
        if err
          STDERR.puts "Error: #{err}"
          exit 1
        end
        response = res
      end
      next_page_token = response.next_page_token

      puts "nextPageToken: #{next_page_token}"
      plus = next_page_token ? "+" : ""

      unless response.history
        puts "No records since #{last_history_id}."
        return 0
      end

      puts "#{response.history.length}#{plus} historie(s):"

      response.history.each do |h|
        history = Glima::Resource::History.new(h)
        puts history.dump
      end
    end while next_page_token
  end

  ################################################################
  # Command: dezip
  ################################################################
  desc "dezip GM_MSGID DIRECTORY", "Decrypt zip found in GM_MSGID to DIRECTORY"

  def dezip(pivot_id, directory)
    pivot_mail = nil

    client.get_user_smart_message(pivot_id) do |m, err|
      fail "#{err}" if err
      pivot_mail = m
    end

    # find password candidate from emails
    password_candidates = [nil]
    index = 1

    client.nearby_messages(pivot_mail) do |message|
      next if message.id == pivot_id
      puts format_message(index, message)
      message = datastore.update(message)
      mail = Glima::Resource::Mail.new(message)

      password_candidates += mail.find_passwordish_strings
      index += 1
    end

    password_candidates.uniq!

    # try all passwords to attachment
    pivot_mail.attachments.each do |attachment|
      if attachment.filename =~ /\.zip$/i
        zip_filename = File.expand_path(attachment.filename, directory)

        zip = Glima::Zip.new(attachment.body.decoded)

        # try all passwords
        password_candidates.each do |password|
          STDERR.print "Try password:'#{password}'..."
          if zip.correct_password?(password)
            STDERR.puts "succeeded."
            zip.password = password
            STDERR.print "Writing to #{zip_filename || 'STDOUT'}..."
            zip.to_decrypted_unicode_zip.write_to_file(zip_filename)
            STDERR.puts "done."
            break
          else
            STDERR.puts "failed."
          end
        end

      end
    end
  end

  ################################################################
  # Command: scan
  ################################################################
  desc "scan +FOLDER SEARCH_OR_RANGE", "Scan mails in FOLDER with SEARCH_OR_RANGE."

  method_option :mew, :desc => "Make Mew virtual-summary buffer", :type => :boolean

  def scan(folder, search_or_range = nil)
    index = 1
    client.scan_batch(folder, search_or_range) do |message|
      puts format_message(index, message, options[:mew])
      index += 1
    end
  end

  ################################################################
  # Command: show
  ################################################################
  desc "show GM_MSGID", "Show article by GM_MSGID."

  method_option :raw, :desc => "Cat raw mail article.", :type => :boolean

  def show(id)
    client.get_user_smart_message(id) do |message|
      if options[:raw]
        print message.raw
      else
        print message.to_plain_text
      end
    end
  end

  ################################################################
  # Command: open
  ################################################################
  desc "open GM_MSGID", "Open article in browser by GM_MSGID"

  def open(id)
    Launchy.open("https://mail.google.com/mail/u/1/#all/#{id}")
  end

  ################################################################
  # Command: guess
  ################################################################
  desc "guess GM_MSGID", "Guess labels to add to GM_MSGID"

  def guess(message_id)
    fmt = "minimal"
    user_label_ids = []

    msg = client.get_user_message('me', message_id, format: fmt)
    thr = client.get_user_thread('me', msg.thread_id, format: fmt)

    thr.messages.each do |tmsg|
      # puts tmsg.snippet
      tmsg.label_ids.each do |label_id|
        next unless label_id =~ /^Label_\d+$/
        user_label_ids << label_id unless user_label_ids.member?(label_id)
        puts "#{tmsg.id} -> #{label_id}"
      end
    end

    user_label_ids.each do |label_id|
      label = client.get_user_label('me', label_id)
      puts "#{label_id} -> #{label.name}"
    end
  end

  ################################################################
  # Command: relabel
  ################################################################
  desc "relabel OLD_NAME NEW_NAME", "Rename label OLD_NAME to NEW_NAME."

  expand_option :dry_run

  def relabel(source_name, dest_name)
    client = Glima::GmailClient.new(config.general, self).client

    all_labels = client.list_user_labels('me').labels.sort_by(&:name)

    if /\/$/ =~ dest_name
      move_to_dir = true
      dest_name = dest_name.sub(/\/$/, '')
    else
      move_to_dir = false
    end

    source_labels = all_labels.find_all {|x| File.fnmatch(source_name, x.name, File::FNM_PATHNAME)}
    dest_label    = all_labels.find {|x| x.name == dest_name}

    if source_labels.empty?
      puts "Error: source #{source_name} not found"
      return nil
    end

    if dest_label && !move_to_dir
      puts "Error: dest #{dest_name} already exists"
      return nil
    end

    if !dest_label && move_to_dir
      puts "Error: dest #{dest_name} not found"
      return nil
    end

    source_labels.each do |source_label|
      dirtop = File.dirname(source_label.name)
      sub_labels = all_labels.find_all {|x| File.fnmatch(source_label.name + '/*', x.name)}

      ([source_label] + sub_labels).each do |label|
        src = label.name
        dst = dest_name + '/' + (label.name.sub(/^#{dirtop}\//, ''))

        if all_labels.find {|x| x.name == dst}
          puts "Error: relabel #{src} -> #{dst}: Destination already exists"
          next
        else
          puts "relabel #{src} -> #{dst}"
        end

        unless options[:dry_run]
          label_obj = Google::Apis::GmailV1::Label.new(id: label.id, name: dst)
          client.patch_user_label('me', label.id, label_obj) do |response, err|
            if response
              # puts dump_label(response)
            else
              puts "Error: #{err}"
            end
          end
        end
      end
    end
  end


  ################################################################
  # Command: inc
  ################################################################
  desc "inc", "Incorporate messages into +inbox"

  def inc
    next_page_token = nil
    count = 0

    begin
      opt = {q: "in:inbox"}
      opt[:page_token] = next_page_token if next_page_token

      response = client.list_user_messages('me', opt)

      if response.messages.empty?
        puts 'No messages found'
        return 0
      end

      next_page_token = response.next_page_token

      ids = []
      response.messages.map(&:id).each do |id|
        next if datastore.exist?(id)
        ids << id
      end

      next if ids.empty?

      client.batch do |batch_client|
        ids.each do |id|
          batch_client.get_user_message('me', id, format: "raw") do |m, err|
            count += 1
            if m
              # id = save_message_in_num(m, "+all")
              # id = save_message_in_id(m, "+all")
              message = datastore.update(m)
              puts format_message(count, message)
              # puts "#{count} #{id} #{m.snippet[0..40]}..."
            else
              STDERR.puts "Error: #{err}"
            end
          end
        end
      end
    end while next_page_token
  end

  ################################################################
  # private

  private

  def push_mail_to_server(mail)
    labels = options[:label]&.split(/ *, */) || []
    label_ids = client.list_user_labels('me').labels.find_all {|lbl| labels.member?(lbl.name)}.map(&:id)
    label_ids += ["INBOX", "UNREAD"]
    thid = options[:thread] || nil
    date = if options[:date] == "header" then "dateHeader" else "receivedTime" end

    File.open(email_file) do |source|
      client.insert_user_message(
        'me',
        Google::Apis::GmailV1::Message.new(label_ids: label_ids, thread_id: thid),
        content_type: "message/rfc822",
        internal_date_source: date,
        upload_source: source) do |msg, err|
        if msg
          puts "pushed to: #{msg.id}"
        else
          STDERR.puts "Error: #{err}"
        end
      end
    end
  end

  def format_message(count, message, add_mew_link = false)
    return format_message_mew_virtual(count, message) if add_mew_link

    date = Time.at(message.internal_date.to_i/1000).strftime("%m/%d %H:%M")
    return "#{"%4d" % count} #{date} #{message.id} #{CGI.unescapeHTML(message.snippet)[0..30]}"
  end

  def format_message_mew_virtual(count, message)
    date = Time.at(message.internal_date.to_i/1000).strftime("%m/%d ")
    mail = Glima::Resource::Mail.new(message)

    mark1 = " "
    mark1 = "U" if message.label_ids.include?("UNREAD")

    mark2 = " "
    mark2 = "-" if mail.content_type =~ /multipart\/alternative/
    mark2 = "M" unless mail.attachments.empty?

    folder = File.expand_path("~/Mail/all") # XXX

    summary = "#{mark1}#{mark2}#{date} #{CGI.unescapeHTML(message.snippet)}"
    summary += "\r +#{folder} #{message.id} <#{message.id}>"
    summary += if message.id != message.thread_id then " <#{message.thread_id}>" else " " end

    return summary + " 1 2"
  end

  def store_page_token(page_token)
    context.save_page_token(page_token)
  end

  attr_reader :builder, :config, :client, :context, :datastore

  def setup_global_options
    exit_on_error do
      @config = Glima::Config.create_from_file(options[:config] || CONFIG_PATH)
      @datastore = Glima::DataStore.new(File.expand_path("~/Mail"))
      @client = Glima::GmailClient.new(config.general, @datastore)
      @context = Glima::Context.new(File.expand_path(CONFIG_HOME))

      if options[:profile]
        require 'profiler'
        Profiler__.start_profile
      end
      if options[:debug]
        require "pp"
        $GLIMA_DEBUG = true
        $GLIMA_DEBUG_FOR_DEVELOPER = true if ENV["GLIMA_DEBUG_FOR_DEVELOPER"]
      end
    end
  end
end

GlimaCLI.start(ARGV)

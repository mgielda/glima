#!/usr/bin/env ruby

################################################################
# rbenv support:
# If this file is a symlink, and bound to a specific ruby
# version via rbenv (indicated by RBENV_VERSION),
# I want to resolve the symlink and re-exec
# the original executable respecting the .ruby_version
# which should indicate the right version.
#
if File.symlink?(__FILE__) and ENV["RBENV_VERSION"]
  ENV["RBENV_VERSION"] = nil
  shims_path = File.expand_path("shims", ENV["RBENV_ROOT"])
  ENV["PATH"] = shims_path + ":" + ENV["PATH"]
  exec(File.readlink(__FILE__), *ARGV)
end

gemfile = File.expand_path("../../Gemfile", __FILE__)

if File.exists?(gemfile + ".lock")
  ENV["BUNDLE_GEMFILE"] = gemfile
  require "bundler/setup"
end

require "rubygems"
require "glima"
require "cgi"
require "logger"

Encoding.default_external="UTF-8"

class GlimaCLI < Glima::Cli
  package_name 'GLIMA'

  ################################################################
  # register frequently used options

  named_option :format,     :desc => "Set printing format", :enum => %w(short full metadata minimal raw mewl)
  named_option :dry_run,    :desc => "Perform a trial run with no changes made", :type => :boolean
  named_option :query,      :desc => "Filter messages by QUERY"

  ################################################################
  # Command: dezip
  ################################################################
  desc "dezip GM_MSGID DIRECTORY", "Decrypt zip found in GM_MSGID to DIRECTORY"

  method_option :zip_passwords_file, :desc => "Set additional password-list file."

  def dezip(gmail_id, directory)
    password_file = options[:password_file] || config.general.zip_passwords_file
    Glima::Command::Dezip.new(client, logger, gmail_id, directory, password_file)
  end

  ################################################################
  # Command: events
  ################################################################
  desc "events SINCE", "List operation history SINCE."

  def events(since)
    client.each_events(since: since) do |ev|
      puts ev.dump
    end
  end

  ################################################################
  # Command: guess
  ################################################################
  desc "guess GM_MSGID", "Guess labels to add to GM_MSGID"

  def guess(message_id)
    Glima::Command::Guess.new(client, logger, message_id)
  end

  ################################################################
  # Command: label
  ################################################################
  desc "label GM_MSGID", "Add/Remove labels to/from GM_MSGID"

  method_option :add, :desc => "List of label names to add separated by comma"
  method_option :del, :desc => "List of label names to del separated by comma"

  def label(message_id)
    add = parse_label_names(options[:add])
    del = parse_label_names(options[:del])
    Glima::Command::Label.new(client, logger, message_id, add, del)
  end

  ################################################################
  # Command: labels
  ################################################################
  desc "labels", "List labels"

  method_option :verbose, :desc => "Show verbose information for each label.", :type => :boolean

  def labels
    Glima::Command::Labels.new(client, logger, options[:verbose])
  end

  ################################################################
  # Command: open
  ################################################################
  desc "open GM_MSGID", "Open article in browser by GM_MSGID"

  def open(id)
    Launchy.open("https://mail.google.com/mail/u/1/#all/#{id}")
  end

  ################################################################
  # Command: profile
  ################################################################
  desc "profile", "Show user's profile."

  def profile
    Glima::Command::Profile.new(client, logger)
  end

  ################################################################
  # Command: push
  ################################################################
  desc "push EMAIL_FILE", "Push EMAIL_FILE to INBOX"

  method_option :date,   :desc => "Set date source", :enum => %w(time header)
  method_option :thread, :desc => "Set thread Id"
  method_option :label,  :desc => "List of label names to add separated by comma"

  def push(email_file)
    labels = parse_label_names(options[:label])
    date = if options[:date] == "header" then "dateHeader" else "receivedTime" end
    Glima::Command::Push.new(client, logger, email_file, date, options[:thread], labels)
  end

  ################################################################
  # Command: relabel
  ################################################################
  desc "relabel OLD_NAME NEW_NAME", "Rename label OLD_NAME to NEW_NAME."

  expand_option :dry_run

  def relabel(source_name, dest_name)
    Glima::Command::Relabel.new(client, logger, source_name, dest_name, options[:dry_run])
  end

  ################################################################
  # Command: scan
  ################################################################
  desc "scan +FOLDER SEARCH_OR_RANGE", "Scan mails in FOLDER with SEARCH_OR_RANGE."

  method_option :format, :desc => "Set printing format", :enum => %w(mew text)

  def scan(folder, search_or_range = nil)
    format = options[:format].to_s.to_sym
    Glima::Command::Scan.new(client, logger, folder, format, search_or_range)
  end

  ################################################################
  # Command: show
  ################################################################
  desc "show GM_MSGID", "Show article by GM_MSGID."

  method_option :raw, :desc => "Cat raw mail article.", :type => :boolean

  def show(id)
    client.get_user_smart_message(id) do |message|
      error_and_exit("No message found id:#{id}.") unless message

      if options[:raw]
        print message.raw
      else
        print message.to_plain_text
      end
    end
  end

  ################################################################
  # Command: trash
  ################################################################
  desc "trash GM_MSGID ...", "Move messages to trash"

  def trash(*message_ids)
    if message_ids.empty?
      puts "Do nothing."
      return 0
    end
    Glima::Command::Trash.new(client, logger, message_ids)
  end

  ################################################################
  # Command: watch
  ################################################################
  desc "watch QUEUE_LABEL", "Watch gmail server and xzip."

  def watch(queue_label, mark_label)
    queue_label = parse_label_names(queue_label).first
    mark_label  = parse_label_names(mark_label).first
    Glima::Command::Watch.new(client, logger, queue_label, mark_label)
  end

  ################################################################
  # Command: xzip
  ################################################################
  desc "xzip TARGET", "Transform zip-attachments in TARGET and transmit to Gmail."

  method_option :add_src_labels, :desc => "Add labels to source",        :banner => "LABEL,..."
  method_option :add_dst_labels, :desc => "Add labels to destination",   :banner => "LABEL,..."
  method_option :del_src_labels, :desc => "Del labels from source",      :banner => "LABEL,..."
  method_option :del_dst_labels, :desc => "Del labels from destination", :banner => "LABEL,..."

  def xzip(target)
    Glima::Command::Xzip.new(client, logger, target,
                             add_src_labels: parse_label_names(options[:add_src_labels]),
                             del_src_labels: parse_label_names(options[:del_src_labels]),
                             add_dst_labels: parse_label_names(options[:add_dst_labels]),
                             del_dst_labels: parse_label_names(options[:del_dst_labels]))
  end

  ################################################################
  # private

  private

  def error_and_exit(message)
    STDERR.puts message
    exit 1
  end

  def parse_label_names(label_names)
    (label_names&.split(/ *, */) || []).map do |name|
      unless label = client.label_by_name(name)
        error_and_exit("No label named #{name}")
      end
      label
    end
  end

  attr_reader :builder, :config, :client, :context, :logger

  def setup_global_options
    exit_on_error do
      @config = Glima::Config.create_from_file(options[:config] || CONFIG_PATH)
      @datastore = Glima::DataStore.new(File.expand_path("~/Mail"))
      @client = Glima::GmailClient.new(config.general, @datastore)
      @context = Glima::Context.new(File.expand_path(CONFIG_HOME))

      @logger = ::Logger.new($stderr)
      @logger.formatter = proc {|severity, datetime, progname, msg| "#{msg}\n"}

      if options[:profile]
        require 'profiler'
        Profiler__.start_profile
      end
      if options[:debug]
        require "pp"
        $GLIMA_DEBUG = true
        $GLIMA_DEBUG_FOR_DEVELOPER = true if ENV["GLIMA_DEBUG_FOR_DEVELOPER"]
      end
    end
  end
end

GlimaCLI.start(ARGV)
